% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Find_Annotation_Markers.R
\name{Find_Annotation_Markers}
\alias{Find_Annotation_Markers}
\title{Get the top markers for fast annotation}
\usage{
Find_Annotation_Markers(
  seurat_object,
  ident.1 = NULL,
  ident.2 = NULL,
  min.pct = 0.25,
  top.markers = 5,
  unique.markers = TRUE,
  filter.mito = TRUE,
  filter.ribo = TRUE,
  filter.ncRNA = TRUE,
  species = "human",
  parallelized = FALSE,
  BPPARAM = NULL,
  output.df = FALSE,
  output.list = FALSE,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{seurat_object}{A \pkg{Seurat} object.}

\item{ident.1}{Character. (from \code{\link[Seurat]{FindMarkers}} documentation) Identity class to define markers for; pass an object of class \code{phylo} or 'clustertree' to find markers for a node in a cluster tree; passing 'clustertree' requires \code{\link[Seurat]{BuildClusterTree}} to have been run. Leave \code{NULL} to find markers for all clusters.}

\item{ident.2}{Character. (from \code{\link[Seurat]{FindMarkers}} documentation) A second identity class for comparison; if \code{NULL}, use all other cells for comparison; if an object of class \code{phylo} or 'clustertree' is passed to \code{ident.1}, must pass a node to find markers for.}

\item{min.pct}{Numeric. (from \code{\link[Seurat]{FindMarkers}} documentation) Only test features that are detected in a minimum fraction of min.pct cells in either of the two populations. Meant to speed up the function by not testing features that are very infrequently expressed.}

\item{top.markers}{Numeric. The number of top markers to return. If set to \code{Inf}, all markers will be returned.}

\item{unique.markers}{Logical. If \code{TRUE}, unique markers will be returned for each identity in order to prevent features repeated multiple times.}

\item{filter.mito}{Logical. If \code{TRUE}, mitochondrial features will be filtered out.}

\item{filter.ribo}{Logical. If \code{TRUE}, ribosomal features will be filtered out.}

\item{filter.ncRNA}{Logical. If \code{TRUE}, non-coding RNA features will be filtered out.}

\item{species}{Character. The species from which to pull data from to filter out features. If 'human', non-coding RNA features will be filtered out from a dataset named ncRNA_human built from \href{https://www.genenames.org/data/genegroup/#!/group/475}{genenames database}. If 'mouse', only pseudogenes will be filtered out based on a dataset named pseudogenes_mouse and built from \href{https://rna.sysu.edu.cn/dreamBase2/scrna.php?SClade=mammal&SOrganism=mm10&SDataId=0&SProteinID=0}{dreamBase2 database}. These datasets are loaded with \pkg{RightSeuratTools} and may be checked for more information.}

\item{parallelized}{Logical. If \code{TRUE}, \code{\link[Seurat]{FindMarkers}} will be parallelized using \pkg{BiocParallel}. Please note that parallelization is complex and depends on your system operating system (Windows users might not see a gain or might even experience a slowdown).}

\item{BPPARAM}{A \code{\link[BiocParallel]{BiocParallelParam}} object to be used for parallelization. If \code{NULL}, the function will set this parameter to \code{\link[BiocParallel]{SerialParam}}, which uses a single worker (core) and is therefore not parallelized, in order to prevent accidental use of large computation resources. Ignored if \code{parallelized} = \code{FALSE}.}

\item{output.df}{Logical. If \code{TRUE}, a data frame of features names and associated statistics will be returned. If \code{FALSE}, a character vector of features names will be returned.}

\item{output.list}{Logical. If \code{TRUE}, a list of data frames for each identity with features names and statistics or a list of character vectors containing features names if \code{output.df} = \code{FALSE} will be returned.}

\item{verbose}{Logical. If \code{FALSE}, does not print progress messages and output, but warnings and errors will still be printed.}

\item{...}{Additional arguments to be passed to \code{\link[Seurat]{FindMarkers}}, such as \code{test.use}, or passed to other methods and to specific DE methods.}
}
\value{
A data frame or a list of data frames with features names and associated statistics, or a character vector or a list of character vectors with features names.
}
\description{
This function is a wrapper around \code{\link[Seurat]{FindMarkers}} that allows for parallelization and filtering of mitochondrial, ribosomal and non-coding RNA features in human, as well as filtering of pseudogenes in mouse. It will also directly return the top X markers for each identity.
}
\examples{
\dontshow{
suppressWarnings(suppressPackageStartupMessages(library(Seurat)))
suppressWarnings(suppressPackageStartupMessages(library(SeuratData)))
suppressWarnings(suppressMessages(InstallData("pbmc3k")))
suppressWarnings(suppressMessages(data(pbmc3k)))
pbmc3k = suppressWarnings(suppressMessages(UpdateSeuratObject(pbmc3k)))
pbmc = suppressWarnings(suppressMessages(Right_DietSeurat(pbmc3k, idents = "orig.ident")))

pbmc[["percent.mt"]] <- suppressWarnings(suppressMessages(PercentageFeatureSet(pbmc, pattern = "^MT-")))

pbmc <- suppressWarnings(suppressMessages(subset(pbmc, subset = nFeature_RNA > 400 &
                 nFeature_RNA < 2500 &
                 percent.mt < 10)))

pbmc <- suppressWarnings(suppressMessages(NormalizeData(pbmc, verbose = FALSE)))
pbmc <- suppressWarnings(suppressMessages(FindVariableFeatures(pbmc, verbose = FALSE)))
pbmc <- suppressWarnings(suppressMessages(ScaleData(pbmc, features = rownames(pbmc), verbose = FALSE)))
pbmc <- suppressWarnings(suppressMessages(RunPCA(pbmc, verbose = FALSE)))
pbmc <- suppressWarnings(suppressMessages(FindNeighbors(pbmc, dims = 1:10, verbose = FALSE)))
pbmc <- suppressWarnings(suppressMessages(FindClusters(pbmc, resolution = 0.5, verbose = FALSE)))
pbmc <- suppressWarnings(suppressMessages(RunUMAP(pbmc, dims = 1:10, verbose = FALSE)))
new.cluster.ids <- c("Naive CD4 T", "CD14+ Mono", "Memory CD4 T",
                     "B", "CD8 T", "FCGR3A+ Mono", "NK", "DC")
names(new.cluster.ids) <- levels(Idents(pbmc))
pbmc <- suppressWarnings(suppressMessages(RenameIdents(pbmc, new.cluster.ids)))
}
# Timer function

time.it = function(fun) {
  start.time = Sys.time()
  fun
  print(Sys.time()-start.time)
  return(fun)
}

# Example 1: default parameters

pbmc.markers = time.it(Find_Annotation_Markers(pbmc))

head(pbmc.markers, 5)

# Example 2: parallelized FindAllMarkers

BPPARAM = BiocParallel::registered()[[1]]
if (BPPARAM$workers > 4) BPPARAM$workers = 4

pbmc.markers = time.it(Find_Annotation_Markers(pbmc,
                                       min.pct = 0.01,
                                       top.markers = Inf,
                                       unique.markers = FALSE,
                                       filter.mito = FALSE,
                                       filter.ribo = FALSE,
                                       filter.ncRNA = FALSE,
                                       parallelized = TRUE,
                                       BPPARAM = BPPARAM,
                                       output.df = TRUE))

head(pbmc.markers, 5)
}
