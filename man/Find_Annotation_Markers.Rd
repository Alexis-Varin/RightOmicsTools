% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Find_Annotation_Markers.R
\name{Find_Annotation_Markers}
\alias{Find_Annotation_Markers}
\title{Find_Annotation_Markers}
\usage{
Find_Annotation_Markers(
  seurat_object,
  ident.1 = NULL,
  ident.2 = NULL,
  min.pct = 0.25,
  top.markers = 5,
  unique.markers = TRUE,
  filter.mito = TRUE,
  filter.ribo = TRUE,
  filter.ncRNA = TRUE,
  species = "human",
  parallelized = FALSE,
  BPPARAM = NULL,
  output.df = TRUE,
  output.list = FALSE,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{seurat_object}{A Seurat object.}

\item{ident.1}{Character. Identity class to define markers for; pass an object of class phylo or 'clustertree' to find markers for a node in a cluster tree; passing 'clustertree' requires BuildClusterTree to have been run. Leave NULL to find markers for all clusters.}

\item{ident.2}{Character. A second identity class for comparison; if NULL, use all other cells for comparison; if an object of class phylo or 'clustertree' is passed to ident.1, must pass a node to find markers for.}

\item{min.pct}{Numeric. Only test genes that are detected in a minimum fraction of min.pct cells in either of the two populations. Meant to speed up the function by not testing genes that are very infrequently expressed.}

\item{top.markers}{Numeric. The number of top markers to return. If set to Inf, all markers will be returned.}

\item{unique.markers}{Logical. If TRUE, unique markers will be returned for each cluster in order to prevent markers repeated in multiple clusters.}

\item{filter.mito}{Logical. If TRUE, mitochondrial genes will be filtered out.}

\item{filter.ribo}{Logical. If TRUE, ribosomal genes will be filtered out.}

\item{filter.ncRNA}{Logical. If TRUE, non-coding RNA genes will be filtered out.}

\item{species}{Character. The species from which to pull data to filter out genes. If "human", non-coding RNA genes will be filtered out from a dataset named ncRNA_human built from genenames database. If "mouse", only pseudogenes will be filtered out based on a dataset named pseudogenes_mouse and built from dreamBase2 database. These datasets are loaded with RightSeuratTools package and may be checked for more information.}

\item{parallelized}{Logical. If TRUE, FindMarkers will be parallelized using BiocParallel.}

\item{BPPARAM}{A BiocParallelParam object to be used for parallelization. If NULL, will use SerialParam() which is not parallelized. Ignored if parallelized = FALSE.}

\item{output.df}{Logical. If TRUE, a data frame of gene names and associated statistics will be returned. If FALSE, a character vector of gene names will be returned.}

\item{output.list}{Logical. If TRUE, a list of gene names with or without statistics for each cluster will be returned.}

\item{verbose}{Logical. If FALSE, does not print progress messages and output, but warnings and errors will still be printed.}

\item{...}{Additional arguments to be passed to FindMarkers, such as test.use, or other methods and to specific DE methods downstream of FindMarkers.}
}
\value{
A data frame or a list of data frames with gene names and associated statistics, or a character vector or a list of character vectors with gene names.
}
\description{
This function is a wrapper around Seurat's FindMarkers function that allows for parallelization and filtering of mitochondrial, ribosomal and non-coding RNA genes in human, as well as filtering of pseudogenes in mouse. It will also directly give the top X markers for each identity to use for plotting with DotPlot_Heatmap() for example.
}
\examples{
library(Seurat)

# Original object from SeuratObject:

pbmc_small

# Example of parallelized FindAllMarkers
# (provided you set your future::plan() to multisession or multicore):

Find_Annotation_Markers(pbmc_small,
                       min.pct = 0.01,
                       top.markers = Inf,
                       unique.markers = FALSE,
                       filter.mito = FALSE,
                       filter.ribo = FALSE,
                       filter.ncRNA = FALSE,
                       parallelized = TRUE,
                       output.list = FALSE)
}
