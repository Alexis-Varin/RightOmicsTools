% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DotPlot_Heatmap.R
\name{DotPlot_Heatmap}
\alias{DotPlot_Heatmap}
\title{DotPlot_Heatmap}
\usage{
DotPlot_Heatmap(
  seurat_object,
  assay = "RNA",
  layer = "data",
  data.are.log = TRUE,
  features = NULL,
  split.by = NULL,
  idents = NULL,
  split.idents = NULL,
  scale = TRUE,
  rotate.axis = FALSE,
  dotplot = TRUE,
  dots.type = "square root",
  dots.size = 4,
  show.na.dots = FALSE,
  col.min = "q0",
  col.max = "q100",
  data.colors = list(dotplot = c("#35A5FF", "lightgrey", "red"), heatmap = c("#35A5FF",
    "white", "red")),
  na.color = "black",
  idents.colors = NULL,
  show.idents.names.colors = TRUE,
  show.idents.dend.colors = TRUE,
  split.colors = NULL,
  show.split.names.colors = TRUE,
  show.split.dend.colors = TRUE,
  kmeans.repeats = 100,
  cluster.rows = TRUE,
  row.kmeans = 1,
  row.names.side = "left",
  row.names.width = unit(15, "cm"),
  cluster.columns = TRUE,
  column.kmeans = 1,
  column.names.rotation = 45,
  column.names.side = "bottom",
  column.names.height = unit(15, "cm"),
  inner.border = TRUE,
  outer.border = TRUE,
  data.legend.name = NULL,
  data.legend.side = "bottom",
  data.legend.direction = "horizontal",
  data.legend.position = "topcenter",
  data.legend.width = 5,
  idents.legend.name = "Active identities",
  show.idents.legend = TRUE,
  split.legend.name = "Split identities",
  show.split.legend = TRUE,
  output.data = FALSE,
  ...
)
}
\arguments{
\item{seurat_object}{A Seurat object.}

\item{assay}{Character. If the Seurat object contains multiple RNA assays, you may specify which one to use (for example "RNA2" if you have created a second RNA assay you named "RNA2". See Seurat v5 vignettes for more information). You may also use another assay such as SCT to pull gene expression from.}

\item{layer}{Character. Formerly known as slot. It is recommended to use 'data'.}

\item{data.are.log}{Logical. If TRUE, tells the function data are log transformed. If, and only if, layer = 'data', feature values are exponentiated (using expm1()) so that averaging is done in non-log space (as per Seurat's default behavior for its own DotPlot() or AverageExpression() functions), after that, average expression is log transformed back (using log1p()). If FALSE, and/or layer = 'scale.data' or 'counts', feature values are not exponentiated prior to averaging.}

\item{features}{Character. A vector of features to plot.}

\item{split.by}{Character. The name of an identity in the metadata slot to split the active.ident identity by.}

\item{idents}{Character. A vector with one or several identities in the active.ident identity to use if you only want those (instead of subsetting your object). If NULL, all identities will be used.}

\item{split.idents}{Character. A vector with one or several identities in the split.by identity to use if you only want those. If NULL, all identities will be used.}

\item{scale}{Logical. If TRUE, the data will be scaled.}

\item{rotate.axis}{Logical. If TRUE, flips the axis, so that genes are displayed as rows and identities as columns.}

\item{dotplot}{Logical. If TRUE, the function will create a dotplot, with dot size proportional to the percentage of cells expressing the feature. If FALSE, the function will create a heatmap. Credits to https://divingintogeneticsandgenomics.com/post/clustered-dotplot-for-single-cell-rnaseq/ for the layer_fun function that draws the dots.}

\item{dots.type}{Character. Determines the dot size difference between 0 and 100\% expression. Either 'square root' (lower difference) or 'radius' (higher difference). Ignored if dotplot = FALSE.}

\item{dots.size}{Numeric. The size of the dots in the dotplot. Ignored if dotplot = FALSE.}

\item{show.na.dots}{Logical. If TRUE, the function will display a small dot for features that are not expressed (0\% expression) instead of nothing. Ignored if dotplot = FALSE.}

\item{col.min}{Character or Numeric. The minimum value for the color scale parameter internally passed to colorRamp2::colorRamp2(). If character, must be a quantile in the form 'qX' where X is a number between 0 and 100. 'q0' by default, which is the minimum value of the expression matrix. A value of 'q2' or 'q5' is useful to reduce the effect of outlier values (e.g. a very low value that significantly alters the color scale range of all other values).}

\item{col.max}{Character or Numeric. The maximum value for the color scale parameter internally passed to colorRamp2::colorRamp2(). If character, must be a quantile in the form 'qX' where X is a number between 0 and 100. 'q100' by default, which is the maximum value of the expression matrix. A value of 'q98' or 'q95' is useful to reduce the effect of outlier values (e.g. a very high value that significantly alters the color scale range of all other values).}

\item{data.colors}{Character or List. Either a vector of exactly 3 colors, corresponding to the lowest, middle, and highest values of the expression matrix and internally passed to colorRamp2::colorRamp2(), or a single character value corresponding to the name of a palette internally passed to the hcl_palette parameter of colorRamp2::colorRamp2() (such as 'Inferno', 'Berlin', 'Viridis' etc, check grDevices::hcl.pals() for all palettes available), or a named list of two vectors of 3 colors or 1 palette, one for the dotplot and one for the heatmap.}

\item{na.color}{Character. The color to use for NA values. Ignored if dotplot = TRUE.}

\item{idents.colors}{Character. A vector of colors to use for the active.ident identity, of same length as the number of identities in the active.ident identity or supplied to the idents parameter. If NULL, uses Seurat's default colors.}

\item{show.idents.names.colors}{Logical. If TRUE, the function will display the colors specified by the idents.colors parameter next to identity names.}

\item{show.idents.dend.colors}{Logical. If TRUE, the function will display the colors specified by the idents.colors parameter next to the dendogram. Ignored if cluster.rows and cluster.columns are set to FALSE.}

\item{split.colors}{Character. A vector of colors to use for the split.by identity, of same length as the number of identities in the split.by identity or supplied to the split.idents parameter. If NULL, uses a custom palette from grDevices::colors(). Ignored if split.by = NULL.}

\item{show.split.names.colors}{Logical. If TRUE, the function will display the colors specified by the split.colors parameter next to identity names. Ignored if split.by = NULL.}

\item{show.split.dend.colors}{Logical. If TRUE, the function will display the colors specified by the split.colors parameter next to the dendogram. Ignored if split.by = NULL or if cluster.rows and cluster.columns are set to FALSE.}

\item{kmeans.repeats}{Numeric. The number of k-means runs to get a consensus k-means clustering. Ignored if cluster.rows and cluster.columns are set to FALSE.}

\item{cluster.rows}{Logical or Function. If TRUE, the function will cluster the rows. You may also pass an hclust or dendogram object which contains clustering.}

\item{row.kmeans}{Numeric. The number of k-means slices to use for row clustering. Ignored if cluster.rows = FALSE.}

\item{row.names.side}{Character. The side where the row names will be displayed, either 'left' or 'right'. If cluster.rows = TRUE or Function, the dendogram will be displayed on the opposite side.}

\item{row.names.width}{Numeric. The width of the row names. Increase this parameter if your row names are truncated.}

\item{cluster.columns}{Logical or Function. If TRUE, the function will cluster the columns. You may also pass an hclust or dendogram object which contains clustering.}

\item{column.kmeans}{Numeric. The number of k-means slices to use for column clustering. Ignored if cluster.columns = FALSE.}

\item{column.names.rotation}{Numeric. The angle of rotation for the column names.}

\item{column.names.side}{Character. The side where the column names will be displayed, either 'top' or 'bottom'. If cluster.columns = TRUE or Function, the dendogram will be displayed on the opposite side.}

\item{column.names.height}{Numeric. The height of the column names. Increase this parameter if your column names are truncated.}

\item{inner.border}{Logical. If TRUE, the function will display an inner border around each cell of the heatmap. Ignored if dotplot = TRUE.}

\item{outer.border}{Logical. If TRUE, the function will display an outer border around the plot or around each slice if k-means is higher than 1.}

\item{data.legend.name}{Character. The name of the data legend. If NULL, either 'Z-Score' if scale = TRUE, otherwise 'Expression'.}

\item{data.legend.side}{Character. The side of the heatmap where the data legend will be displayed, either 'left', 'right', 'top' or 'bottom'.}

\item{data.legend.direction}{Character. The direction of the data legend, either 'horizontal' or 'vertical'.}

\item{data.legend.position}{Numeric. The centering of the data legend name, there are many options, default option from ComplexHeatmap::Heatmap() is 'topleft'.}

\item{data.legend.width}{Numeric. How long the data legend will be, only affects the data legend if data.legend.direction = 'horizontal'.}

\item{idents.legend.name}{Character. The name of the active.ident identity legend.}

\item{show.idents.legend}{Logical. If TRUE, the function will display a legend for the active.ident identity.}

\item{split.legend.name}{Character. The name of the split.by identity legend. Ignored if split.by = NULL.}

\item{show.split.legend}{Logical. If TRUE, the function will display a legend for the split.by identity.}

\item{output.data}{Logical. If TRUE, the function will return the matrices instead of drawing the heatmap.}

\item{...}{Additional arguments to pass to the ComplexHeatmap::Heatmap() function, such as row_names_gp, clustering_method_columns, etc, accepts any parameter that wasn't already internally passed to ComplexHeatmap::Heatmap() (for example, cluster.columns sets the cluster_columns parameter of the inner function, so you will get an error if you try to pass it again).}
}
\value{
A dotplot, or a heatmap, or a list containing a matrix of the expression data and another matrix containing the percent of cells expressing each feature.
}
\description{
This function generates a dotplot or a heatmap to visualize features expression in a Seurat object.
}
