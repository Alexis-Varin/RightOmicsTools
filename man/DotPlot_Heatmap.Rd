% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/DotPlot_Heatmap.R
\name{DotPlot_Heatmap}
\alias{DotPlot_Heatmap}
\title{Dot plot or heatmap of average gene expression in each identity}
\usage{
DotPlot_Heatmap(
  seurat_object,
  assay = "RNA",
  layer = "data",
  data.are.log = TRUE,
  features,
  split.by = NULL,
  idents = NULL,
  split.idents = NULL,
  scale = TRUE,
  rescale = FALSE,
  rescale.range = c(0, 3),
  rotate.axis = FALSE,
  dotplot = TRUE,
  dots.type = "square root",
  dots.size = 4,
  show.noexpr.dots = FALSE,
  col.min = ifelse(isTRUE(scale), -2, 0),
  col.max = ifelse(isTRUE(scale), 2, "q100"),
  data.colors = if (isTRUE(scale)) c("#35A5FF", "white", "red") else "Viridis",
  palette.reverse = FALSE,
  na.color = "grey40",
  background.color = "white",
  idents.colors = NULL,
  show.idents.names.colors = FALSE,
  show.idents.oppo.colors = TRUE,
  split.colors = NULL,
  show.split.names.colors = FALSE,
  show.split.oppo.colors = TRUE,
  order.idents = NULL,
  order.split = NULL,
  order.colors = TRUE,
  kmeans.repeats = 100,
  cluster.idents = TRUE,
  idents.kmeans = 1,
  idents.kmeans.numbers.size = 11,
  cluster.features = TRUE,
  features.kmeans = 1,
  features.kmeans.numbers.size = 11,
  idents.gap = 1,
  features.gap = 1,
  idents.names.size = 9,
  features.names.size = 9,
  features.names.style = "italic",
  row.names.side = "left",
  row.names.width = unit(15, "cm"),
  column.names.angle = 45,
  column.names.side = "bottom",
  column.names.height = unit(15, "cm"),
  inner.border = TRUE,
  outer.border = TRUE,
  data.legend.name = ifelse(isTRUE(scale), "Z-Score", "Average Expression"),
  data.legend.side = "bottom",
  data.legend.direction = "horizontal",
  data.legend.position = "topcenter",
  data.legend.width = 5,
  idents.legend.name = "Clusters",
  show.idents.legend = TRUE,
  split.legend.name = split.by,
  show.split.legend = TRUE,
  legend.title.size = 10,
  legend.text.size = 10,
  legend.gap = 10,
  output.data = FALSE,
  ...
)
}
\arguments{
\item{seurat_object}{A \pkg{Seurat} object.}

\item{assay}{Character. If the \pkg{Seurat} object contains multiple RNA assays, you may specify which one to use (for example 'RNA2' if you have created a second RNA assay you named 'RNA2'. See \href{https://satijalab.org/seurat/articles/seurat5_essential_commands.html#create-seurat-or-assay-objects}{Seurat v5 vignettes} for more information). You may also use another assay such as 'SCT' to pull features expression from.}

\item{layer}{Character. Formerly known as slot. It is recommended to use 'data'.}

\item{data.are.log}{Logical. If \code{TRUE}, tells the function data are log transformed. If, and only if, \code{layer} = 'data', cell expression values are exponentiated (using \code{\link[base]{expm1}}) so that averaging is done in non-log space (as per \code{\link[Seurat]{DotPlot}} or \code{\link[Seurat]{AverageExpression}}'s default behavior), after that, average expression values are log transformed back (using \code{\link[base]{log1p}}). If \code{FALSE}, or \code{layer} = 'scale.data' or 'counts', cell expression values are not exponentiated prior to averaging.}

\item{features}{Character. A vector of features to plot.}

\item{split.by}{Character. The name of an identity in the meta.data slot to split the active.ident identity by.}

\item{idents}{Character. A vector with one or several identities names in the active.ident identity to use if you only want those (instead of subsetting your object). If \code{NULL}, all identities will be used.}

\item{split.idents}{Character. A vector with one or several identities names in the \code{split.by} identity to use if you only want those. If \code{NULL}, all identities will be used.}

\item{scale}{Logical. If \code{TRUE}, average expression values for each feature will be scaled using \code{\link[base]{scale}} and default parameters. The resulting values will be Z-scores (mean subtracted values divided by standard deviation) and not positive average expression values anymore, which is why there will be positive and negative values displayed, depending on if the average expression in a particular identity is below or above the mean average expression from all identities (which is calculated independently for each feature). Caution should be exercised when interpreting results with low number of identities (typically below 5), as small differences in average expression might lead to exacerbated differences when scaled.}

\item{rescale}{Logical. If \code{TRUE}, average expression values will be adjusted using \code{\link[scales]{rescale}} between the first numerical value of the \code{rescale.range} parameter (lowest expression) and the second numerical value (highest expression) for each feature. This is different than \code{\link[base]{scale}} as this doesn't compare values to any mean or standard deviation and is therefore not a Z-score, it only refits each average expression value (independently for each feature) in order to visualize all features in the same dimension regardless of their differences in levels of expression. Caution should be exercised when interpreting results with low number of identities (typically below 5), as small differences in average expression might lead to exacerbated differences when rescaled. Ignored if \code{scale} = \code{TRUE}.}

\item{rescale.range}{Numeric. A vector specifying the minimum and maximum values to resize the average expression values and internally passed to \code{\link[scales]{rescale}}. These values are arbitrary and will not change the visualization, only the values in the legend, you need to adjust the \code{col.min} and \code{col.max} parameters to influence the color scale. Ignored if \code{rescale} = \code{FALSE} or \code{scale} = \code{TRUE}.}

\item{rotate.axis}{Logical. If \code{TRUE}, flips the axis, so that features are displayed as rows and identities as columns.}

\item{dotplot}{Logical. If \code{TRUE}, the function will display a dotplot, with dots size proportional to the percentage of cells expressing a feature. If \code{FALSE}, the function will instead display a heatmap.}

\item{dots.type}{Character. Determines the dots size difference between 0 and 100\% expression. Either 'square root' (lower difference) or 'radius' (higher difference). Ignored if \code{dotplot} = \code{FALSE}.}

\item{dots.size}{Numeric. The size of the dots in the dotplot. Decreasing this parameter helps when displaying a large number of features. Ignored if \code{dotplot} = \code{FALSE}.}

\item{show.noexpr.dots}{Logical. If \code{TRUE}, the function will display a small dot for features with 0\% expression instead of nothing. Ignored if \code{dotplot} = \code{FALSE}.}

\item{col.min}{Character or Numeric. The minimum value for the \code{breaks} parameter internally passed to \code{\link[colorRamp2]{colorRamp2}}. If character, must be a quantile in the form 'qX' where X is a number between 0 and 100. A value of 'q5' or 'q10' is useful to reduce the effect of outlier values (e.g. a very low value that significantly alters the color scale range of all other values).}

\item{col.max}{Character or Numeric. The maximum value for the \code{breaks} parameter internally passed to \code{\link[colorRamp2]{colorRamp2}}. If character, must be a quantile in the form 'qX' where X is a number between 0 and 100. A value of 'q95' or 'q90' is useful to reduce the effect of outlier values (e.g. a very high value that significantly alters the color scale range of all other values).}

\item{data.colors}{Character. Either a character vector of exactly 3 colors, corresponding to the lowest, zero (or middle if \code{scale} = \code{FALSE}), and highest values in the expression matrix and internally passed to \code{\link[colorRamp2]{colorRamp2}}, or a single character value corresponding to the name of a palette and internally passed to the \code{hcl_palette} parameter of \code{\link[colorRamp2]{colorRamp2}} (such as 'Inferno', 'Berlin', 'Viridis' etc, check \code{\link[grDevices]{hcl.pals}} for all palettes available).}

\item{palette.reverse}{Logical. If \code{TRUE} and if \code{data.colors} is a palette (such as 'Viridis'), the function will reverse its colors.}

\item{na.color}{Character. The color to use for missing values (\code{NA}).}

\item{background.color}{Character. The color to use for the background behind the dots. Ignored if \code{dotplot} = \code{FALSE}.}

\item{idents.colors}{Character. A vector of colors to use for the active.ident identity, of same length as the number of identities in the active.ident identity or supplied to the \code{idents} parameter. If \code{NULL}, uses \pkg{Seurat}'s default colors.}

\item{show.idents.names.colors}{Logical. If \code{TRUE}, the function will display the colors specified by the \code{idents.colors} parameter next to identities names.}

\item{show.idents.oppo.colors}{Logical. If \code{TRUE}, the function will display the colors specified by the \code{idents.colors} parameter on the opposite side of identities names.}

\item{split.colors}{Character. A vector of colors to use for the split.by identity, of same length as the number of identities in the \code{split.by} identity or supplied to the \code{split.idents} parameter. If \code{NULL}, uses a custom set of colors from \code{\link[grDevices]{colors}}. Ignored if \code{split.by} = \code{NULL}.}

\item{show.split.names.colors}{Logical. If \code{TRUE}, the function will display the colors specified by the \code{split.colors} parameter next to identities names. Ignored if \code{split.by} = \code{NULL}.}

\item{show.split.oppo.colors}{Logical. If \code{TRUE}, the function will display the colors specified by the \code{split.colors} parameter on the opposite side of identities names. Ignored if \code{split.by} = \code{NULL}.}

\item{order.idents}{Character or Numeric. A vector specifying either 'reverse' or the levels (as character or as numeric values corresponding to the indexes) of the active.ident identity to order the cells. If \code{cluster.idents} = \code{TRUE} or Function, only the legend names will be ordered.}

\item{order.split}{Character or Numeric. A vector specifying either 'reverse' or the levels (as character or as numeric values corresponding to the indexes) of the \code{split.by} identity to order the cells. If \code{cluster.idents} = \code{TRUE} or Function, only the legend names will be ordered. Ignored if \code{split.by} = \code{NULL}.}

\item{order.colors}{Logical. If \code{TRUE}, the colors for the active.ident identity and the \code{split.by} identity will automatically be ordered according to \code{order.idents} and \code{order.split}. Ignored if \code{order.idents} and \code{order.split} are \code{NULL}.}

\item{kmeans.repeats}{Numeric. The number of k-means runs to get a consensus k-means clustering. Ignored if \code{idents.kmeans} and \code{features.kmeans} are equal to 1.}

\item{cluster.idents}{Logical or Function. If \code{TRUE}, the function will cluster the identities. You may also pass an \code{hclust} or \code{dendrogram} object which contains clustering.}

\item{idents.kmeans}{Numeric. The number of k-means slices to use for identities clustering.}

\item{idents.kmeans.numbers.size}{Numeric. The font size of the identities k-means slices numbers. Set to 0 to remove them.}

\item{cluster.features}{Logical or Function. If \code{TRUE}, the function will cluster the features. You may also pass an \code{hclust} or \code{dendrogram} object which contains clustering.}

\item{features.kmeans}{Numeric. The number of k-means slices to use for features clustering.}

\item{features.kmeans.numbers.size}{Numeric. The font size of the features k-means slices numbers. Set to 0 to remove them.}

\item{idents.gap}{Numeric. The gap between the identities slices. Ignored if \code{idents.kmeans} = 1.}

\item{features.gap}{Numeric. The gap between the features slices. Ignored if \code{features.kmeans} = 1.}

\item{idents.names.size}{Numeric. The font size of the identities names. Set to 0 to remove them.}

\item{features.names.size}{Numeric. The font size of the features names. Set to 0 to remove them.}

\item{features.names.style}{Character. The font face of the features names. The \href{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7494048/}{Gene nomenclature} used by almost all scientific journals require that features names are italicized, therefore the parameter is by default set to 'italic'. Use 'plain' to revert back to regular font face.}

\item{row.names.side}{Character. The side where the row names will be displayed, either 'left' or 'right'. The dendrogram will be displayed on the opposite side.}

\item{row.names.width}{Numeric. The width of the row names. Increase this parameter if your row names are truncated.}

\item{column.names.angle}{Numeric. The angle of rotation of the column names.}

\item{column.names.side}{Character. The side where the column names will be displayed, either 'top' or 'bottom'. The dendrogram will be displayed on the opposite side.}

\item{column.names.height}{Numeric. The height of the column names. Increase this parameter if your column names are truncated.}

\item{inner.border}{Logical. If \code{TRUE}, the function will display a black outline around each dot if \code{dotplot} = \code{TRUE}, or a black border around each cell of the heatmap if \code{dotplot} = \code{FALSE}.}

\item{outer.border}{Logical. If \code{TRUE}, the function will display an outer border around the plot or around each slice if \code{idents.kmeans} and/or \code{features.kmeans} are higher than 1.}

\item{data.legend.name}{Character. The name of the data legend.}

\item{data.legend.side}{Character. The side where the data legend will be displayed, either 'left', 'right', 'top' or 'bottom'.}

\item{data.legend.direction}{Character. The direction of the data legend, either 'horizontal' or 'vertical'.}

\item{data.legend.position}{Character. The centering of the data legend name, there are many options, default option from \code{\link[ComplexHeatmap]{Heatmap}} is 'topleft'.}

\item{data.legend.width}{Numeric. How long the data legend will be, only affects the data legend if \code{data.legend.direction} = 'horizontal'.}

\item{idents.legend.name}{Character. The name of the active.ident identity legend. Ignored if \code{show.idents.names.colors} and \code{show.idents.oppo.colors} are \code{FALSE}.}

\item{show.idents.legend}{Logical. If \code{TRUE}, the function will display a legend for the active.ident identity. Ignored if \code{show.idents.names.colors} and \code{show.idents.oppo.colors} are \code{FALSE}.}

\item{split.legend.name}{Character. The name of the split.by identity legend. Ignored if \code{split.by} = \code{NULL}. Ignored if \code{show.split.names.colors} and \code{show.split.oppo.colors} are \code{FALSE}.}

\item{show.split.legend}{Logical. If \code{TRUE}, the function will display a legend for the split.by identity. Ignored if \code{show.split.names.colors} and \code{show.split.oppo.colors} are \code{FALSE}.}

\item{legend.title.size}{Numeric. The font size of all legend titles.}

\item{legend.text.size}{Numeric. The font size of all legend texts.}

\item{legend.gap}{Numeric. The gap between the legends and the plot. This parameter sets the value in the global options of \code{\link[ComplexHeatmap]{ht_opt}}, so it will affect all \code{\link[ComplexHeatmap]{Heatmap}} objects in the same R session. Use \pkg{ComplexHeatmap}::ht_opt(RESET = \code{TRUE}) to restore default parameters.}

\item{output.data}{Logical. If \code{TRUE}, the function will return a list containing a matrix of the average expression data, scaled or not, and another matrix containing the percentage of cells expressing each feature, instead of displaying anything.}

\item{...}{Additional arguments to be passed to \code{\link[ComplexHeatmap]{Heatmap}}, such as \code{show_parent_dend_line}, \code{clustering_method_rows}, etc, accepts any parameter that wasn't already internally passed to \code{\link[ComplexHeatmap]{Heatmap}} (for example, \code{outer.border} sets the \code{border} parameter of \code{\link[ComplexHeatmap]{Heatmap}}, so you will get an error if you try to pass the \code{border} parameter in \code{\link[RightSeuratTools]{DotPlot_Heatmap}}).}
}
\value{
A \code{\link[ComplexHeatmap]{Heatmap}} object, either as a dotplot, or a heatmap, or a list containing a matrix of the average expression data, scaled or not, and another matrix containing the percentage of cells expressing each feature.
}
\description{
This function generates a dotplot or a heatmap to visualize the average expression of features in each identity of a \pkg{Seurat} object. Credits to \pkg{Seurat}'s dev team for the original \code{\link[Seurat]{DotPlot}} from which data processing of this function is derived from and to \href{https://divingintogeneticsandgenomics.com/post/clustered-dotplot-for-single-cell-rnaseq/}{Ming Tang} for the initial idea to use \pkg{ComplexHeatmap} to draw a dotplot and the \code{layer_fun} function that draws the dots. Various new parameters were added to offer more flexibility and customization.
}
\examples{
\dontshow{
suppressWarnings(suppressPackageStartupMessages(library(Seurat)))
}
# Prepare data
pbmc3k <- Right_Data("pbmc3k")
pbmc3k.markers <- c("CCR7", "CD14", "CD40LG",
                    "CD79A", "CD8A", "CDKN1C",
                    "GNLY", "CLEC10A", "PPBP")

# Example 1: default parameters
DotPlot_Heatmap(pbmc3k,
                features = pbmc3k.markers)
}
